# -*- coding: utf-8 -*-
"""circum_sphere

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YncydsXf5p5nAbBU8vn3qlouo82Y8f18
"""

import numpy as np
from scipy.spatial import Delaunay
from scipy.spatial import distance

import stl
from stl import mesh

# (3D)
# Open the file and read the vertices as strings
with open("bunny.xyz", "r") as f:
    vertex_strings = f.readlines()

# Convert the vertex strings to a NumPy array of shape (N, 3)
points3D = np.zeros((len(vertex_strings), 3))
for i, vertex_str in enumerate(vertex_strings):
    vertex_arr = [float(coord) for coord in vertex_str.strip().split()]
    points3D[i] = vertex_arr

tri = Delaunay(points3D)

# for tetra in tri.simplices:
#     for k in range(len(tetra)):
#         print(points3D[tetra[k%4]],points3D[tetra[(k+1)%4]],points3D[tetra[(k+2)%4]])

# Prepare to collect boundary faces
faces = set()

# Iterate through tetrahedra
for tetra in tri.simplices:
    # For each tetrahedron, consider all four faces
    for i in range(4):
        face = tuple(sorted([tetra[j] for j in range(4) if j != i]))
        if face in faces:
            faces.remove(face)
        else:
            faces.add(face)

# Convert unique faces to array
unique_faces = np.array(list(faces))

# Calculate normals for these faces
normals = np.zeros((len(unique_faces), 3))
for i, face in enumerate(unique_faces):
    v1, v2, v3 = points3D[face]
    normals[i] = np.cross(v2 - v1, v3 - v1)
    normals[i] /= np.linalg.norm(normals[i])

# Create an STL mesh
data = np.zeros(len(unique_faces), dtype=mesh.Mesh.dtype)
stl_mesh = mesh.Mesh(data, remove_empty_areas=False)

# Fill the STL mesh data
for i, f in enumerate(unique_faces):
    for j in range(3):
        stl_mesh.vectors[i][j] = points3D[f[j]]
    stl_mesh.normals[i] = normals[i]

# Save to STL file
stl_mesh.save('output.stl')